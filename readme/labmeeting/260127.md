<Overall flow>
- 나의 이전 연구 REPAIR와 비교
- REPAIR: reranking + adaptive retrieval for each listwise reranking window
    - 이 때 reranking할 때 think는 query에 대한 답이 뭘지 작성
    - corpus는 비슷한 내용끼리 연결한 그래프

- 큰 방향은 
    - 기존 연구에서 plan = query에 대한 답이 뭘지 작성하는 것
    - 지금은 abstraction 을 해야한다 = query에 대한 답이 있을 때 어떤 원리/근거에 기반해서 작성된 답인지 찾는 게 핵심이다
- 변경점
    - query plan -> query abstraction 으로 바뀌고
    - corpus도 비슷한 내용끼리 연결한 (수평적) graph로 표현하는 게 아니라 abstraction한 (계층적) tree 구조로 표현하는 방법 
- 원하는 contribution
    - Abstractive query rewriting (QR) & Corpus tree graph (CG) 사이의 interaction

- 성공한 방향: query rewriting한 다음 flat retrieval하면 ndcg@10 오름. (QR -> CG 성공)
- 실패한 방향: branch node -> query rewriting의 정보
- branch node들로 abstraction schema 만들려고 했는데 실패함, branch node정보가 query rewriting에 도움되지 않음 (CG -> QR 실패)

- 현재 방식: flat retrieval 버리고 adaptive rewriting을 위한 재료로 corpus tree를 쓰자
    - 바뀐 이유
    - iteration4부터 성능 하락, 지금 구현 상으로는 첫번째 iteration에서 no tree traversal 결과 + iteration3 부터 tree path 결과들이 계속 쌓이는데 이게 효과 없음
        - 열어보니 qwen3-4b로는 query rewriting + tree rewriting 효과 없음
        - 그래서 지금 baseline들
            - tree traversal only
            - QR only, no tree traversal
            <naive merge methods>
            - QE + tree traversal
            - tree traversal + iterative rewrite

    - 그러면 왜 corpus tree를 써야 하냐?
        - 가정 1: domain-specific knowledge가 없을 때, abstractive 개념만 브랜치 레벨에서 매칭해준다면 해당 브랜치 밑에 gold doc 있을 것이다
            - If top5 is [leaf1, leaf2, branch3, branch4, leaf5], convert to [leaf1, leaf2, highest-score leaf under branch3, highest-score leaf under branch4, leaf5]
            - [표] 평균은 조금 오른다 (branch -> best leaf)


| Method                                   | bio   | earth | econ  | psych | robot | avg   |
|------------------------------------------|-------|-------|-------|-------|-------|-------|
| Tree-traversal                           | 40.89 | 41.09 | 28.06 | 36.33 | 27.1  | 34.69 |  
| Query rewriting + tree-traversal         | 38.26 | 45.88 | 26.01 | 33.99 | 27.87 | 34.4  |
| Our query rewriting + tree-traversal     | 37.99 | 46.16 | 25.8  | 35.65 | 30.4  | 35.2  |
| Iterative rewriting                      | 49.82 | 52.63 | 27.01 | 40.8  | 23.93 | 38.84 |
| Our iterative rewriting                  | 59.34 | 56.87 | 28.6  | 44.69 | 25.56 | 43.01 |
| Our iterative rewriting EXPLOIT/EXPLORE  | 60.23 | 58.57 | 28.57 | 44.54 | 26.89 | 43.76 |
| branch -> best leaf                      | 63.41 | 59.1  | 26.56 | 43.65 | 27.88 | 44.12 |


        - 가정 2: locality에서 벗어나기 위한 신호 (branch node + leaf node 같이 제공)
            - 현재 스캔 중인 문서 풀이 아닌 문서 풀들은 어디 있냐? 에 대한 답
            - rewrite 할 때는 leaf node만 보여주고 rewrite
            - anchor (leaf+branch) node의 하위 leaf 노드에 대해서만 retrieval: local search
            - 전체 leaf 노드에 대해서만 retrieval: global search
            - (현재는 둘을 RRF 하고있는 상황)
            - 확인: local, global 중 더 ndcg가 높은 것들만 선택한다면 전체 ndcg얼마나 오를지
                - 결과: local 점수, global 점수 차이가 별로 안남


- TODO 를 위한 Oracle 실험
EXPLORE-EXPLOIT을 잘 선택하면 성능이 오른다
BRANCH 밑에 GOLD가 있을 때 그 GOLD를 집으면 최종 성능 얼마나 오르는지도 확인

BRANCH의 분포에 따라서 EXPLORE / EXPLOIT 을 guide해줄 추가 시그널 가능?


<!-- TODO, 고민사항

———

  A. 기본 설계 (추천, 안정적)

  - anchor top‑K 순서를 유지한다.
  - leaf는 그대로 둔다.
  - branch는 해당 branch 아래 leaf 중 가장 높은 점수 leaf로 치환한다.
  - 이미 등장한 leaf면 다음으로 높은 leaf로 대체.
  - 최종 순서도 anchor의 원래 순서를 유지한다.

  이 방식은 “leaf1, leaf2, branch3, branch4” → “leaf1, leaf2, maxleaf3, maxleaf4”
  그대로 구현됨.
  (이미 --round3_anchor_local_rank v1과 일치)

  ———

  B. 성능 하락 방지 규칙 (필요할 수 있음)
  branch replacement가 성능을 깎는 케이스는 대부분 아래 중 하나임:

  1. branch가 너무 shallow해서 내부 leaf가 너무 넓게 퍼짐
  2. branch score는 높지만 실제 leaf가 엉뚱한 경우
  3. 이미 top‑K에 좋은 leaf가 있는데 branch replacement가 noise 추가

  그래서 아래 규칙 중 1~2개만 추가해도 안정성이 좋아짐:

  - depth threshold: depth 1~2 branch는 replacement 안 함
  - score threshold: branch 하위 최고 leaf 점수가 현재 top‑K leaf의 최소 점수보다 낮으면 skip
  - coverage limit: branch replacement 최대 개수 제한 (예: top‑K 중 branch 최대 2개만 교체)

  ———

  C. 상대적 위치를 바꿀 것인가?
  바꾸지 않는 게 안전해.

  - anchor 순서를 유지하면 high‑confidence leaf가 위에 유지됨
  - 재정렬(leaf score 기준)하면 branch에서 나온 leaf가 위로 올라가면서 noise가 커질 수 있음

  그래서 일단은 anchor 순서를 유지하는게 맞아.


<!-- - local / global, explore / exploit 활용법:
    - 기본 idea: 
        - explore뜨면 global에서 정보를 더 가져오기
        - exploit에서는 local에서 query refine
1. explore / exploit을 어떻게 판단하지? 외부 function이 가능할까? (density estimator)
- 서브쿼리별로 판단? 그러면 서브쿼리별로 retrieved results 필요
-  -->

<!-- 지금 논리: corpus tree로 retrieve pool을 제한하는 게 더 성능 오른다. <- 그러면 global 보다 성능이 더 올라야 하는 거 아니냐? --> 
